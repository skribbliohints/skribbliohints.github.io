<!DOCTYPE html>
<html lang='en'>
  <head>
    <title>skribbl.io hints - Search the default word list used by skribbl.io</title>
    <meta name="description" content="The most complete public word list.  Search the list by entering the hint that skribbl.io gives you, for example: _____b____">
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width = device-width, initial-scale = 1">
    <meta name="google-site-verification" content="-WSPNA0Q4EhYOEZRbIHmz6kERwO56vF7Bfze7Ec-d8c" />
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
    <style>
      .b {
        border: 1px solid black;
        border-radius: 3px;
        padding: 1px;
        float: left;
      }


      @media (max-width : 600px) {
        input {
          margin: 3px;
          font-size: 20px;
        }
        .b {
          margin: 3px;
          font-size: 20px;
        }
      }

    </style>
    <script src='Chart.bundle.min.js'></script>
    <script src='grapher.js'></script>
    <script>
      let words = null;
      let sorts = [
        // I have decided to leave them in the order of the word bank, which is by number of words and word lengths.
        // Otherwise there would be comparators here.
      ];
      let word_by_idString = {};
      
      const IDEAL_MINIMUM_PICKED = 15;
      
      const LANGUAGE_TO_PATH_MAP = {
        "English": "EnglishWordBank.json",
        "German": "GermanWordBank.json",
        "Spanish": "SpanishWordBank.json"
      };

      const NAME_MAP = {
        "picked": "Number of times seen",
        "successRate": "Success rate",
        "successRateQuantile": "Success rate quantile"
      };
      function renderKey(key, value, showValue=true) {
        // key and value should be escaped to prevent HTML/JavaScript injection
        if(key in NAME_MAP) {
          return NAME_MAP[key] + (showValue ? ': ' + value : '');
        } else {
          return null;
        }
      }
      function expand(idString) {
        const el = document.getElementById(idString);
        const word = word_by_idString[idString];
        if(el.style.width !== '100%') {
          el.style.width = '100%';
          el.innerHTML = word + `<button style="float: right;" onClick='collapse("${idString}");'>X</button><ul>` +
            Object.keys(words[word]).reduce((acc, key) => {
              const content = renderKey(key, words[word][key]);
              return content ? acc + '<li>' + content + "</li>" : '';
            }, '')
            + '</ul>';
        }
      }
      function collapse(idString) {
        // it doesn't work if I don't use setTimeout here
        setTimeout(function(){
          const word = word_by_idString[idString];
          const el = document.getElementById(idString);
          el.innerHTML = word;
          el.style.width = 'initial';
        }, 1);
      }

      
      function myEscape(text) {
        return text.split('').map(c => ({'<':'&lt;','>':'&gt;','&':'&amp;'}[c] || c)).join('');
      }
      function myRecursiveEscape(a) {
        // a may be of any type except function
        let result;
        if(typeof a === 'number' || typeof a === 'boolean' || typeof a === 'undefined') {
          result = a;
        } else if(typeof a === 'string') {
          result = myEscape(a);
        } else if(typeof a === 'object') {
          if(a === null) {
            result = null;
          } else {
            result = {};
            for(const key in a) {
              result[myEscape(key)] = myRecursiveEscape(a[key]);
            }
          }
        }
        return result;
      }

      function apply_whiteness(val_between_0_and_1, whiteness) {
        return 1 - ((1 - val_between_0_and_1) * (1 - whiteness));
      }
      function get_rgb_string(color_parts_between_0_and_1) {
        return "rgb(" + color_parts_between_0_and_1.map(v => Math.floor(v * 255)).join(',') + ')';
      }
      function get_0_1_rgb_values(q, whiteness) {
        return [apply_whiteness(Math.pow(1 - q, 0.125), whiteness), apply_whiteness(Math.pow(q, 0.125), whiteness), whiteness];
      }
      function getTableInnerHTML(words, sorts=[], filters=[]) {
        let parts = [];

        let word_array = Object.keys(words);
        for(const f of filters) {
          word_array = word_array.filter(f);
        }
        word_array = word_array.sort((a,b) => {
          for(const s of sorts) {
            if(s(a,b) !== s(b,a)) {
              return s(a,b);
            }
          }
          return 0;
        });
        let idNumber = 0;
        for(const word of word_array) {
          let backgroundColorString = '';
          if((document.getElementById('colorCheckbox').checked)) {
            const whiteness = 1 - Math.min(1, words[word].picked / IDEAL_MINIMUM_PICKED);
            const color_parts_between_0_and_1 = get_0_1_rgb_values(words[word].successRateQuantile, whiteness);
            backgroundColorString = "background-color: " + get_rgb_string(color_parts_between_0_and_1) + ';';
          }
          
          // word has already been escaped
          const idString = 'wordDiv' + String(idNumber);
          word_by_idString[idString] = word;
          parts.push(`<div class="b" id="${idString}" style="${backgroundColorString}" onClick="expand('${idString}')">${word}</div>`);
          idNumber++;
        }
        if(parts.length === 0) {
          parts.push('No matching words');
        }
        return parts.join('\n');
      }

      function getFilterFromSkribblioHint(skribblioHint) {
        const re = new RegExp(
          '^' + skribblioHint.split('').map(char => char === '_' ? '[\\p{L}0-9./]' : RegExp.escape(char)).join('') + '$',
          'iu'
        );
        return a => skribblioHint === '' || re.test(a);
      }
      
      function searchBoxOnInput() {
        const input = this.value;
        let filters = [];
        filters.push(getFilterFromSkribblioHint(input));
        document.querySelector('#wordlist').innerHTML = getTableInnerHTML(words, sorts, filters);
      }
      
      
      function colorCheckboxOnClick() {
        searchBoxOnInput.bind(document.getElementById('searchBox'))();
        document.getElementById('colorKey').style.display = this.checked ? "initial" : "none";
      }
      function showGrapherCheckboxOnClick() {
        document.getElementById('grapher').style.display = this.checked ? "initial" : "none";
      }
      function getAttribute(axisSelect) {
        return Object.keys(NAME_MAP).find(attr => renderKey(attr, null, false) === axisSelect.value);
      }
      function showGraph() {
        document.getElementById('graphDiv').innerHTML = '';
        if(xAxisSelect.value !== 'Select') {
          const xAxisSelect = document.getElementById('xAxisSelect');
          const xAxisAttribute = getAttribute(xAxisSelect);
          const yAxisSelect = document.getElementById('yAxisSelect');
          const yAxisAttribute = getAttribute(yAxisSelect);
          let data = [];
          if(yAxisSelect.value === document.getElementById('numWordsWithXOption').textContent) {
            const frequency_map = Object.create(null);
            for(const word in words) {
              const value = words[word][xAxisAttribute];
              frequency_map[value] = (frequency_map[value] || 0) + 1;
            }
            data = Object.keys(frequency_map).map(key => [key, frequency_map[key]]);
          } else {
            for(const word in words) {
              data.push([
                words[word][xAxisAttribute],
                words[word][yAxisAttribute],
                word
              ]);
            }
          }
          document.getElementById('graphDiv').appendChild(getGraph(data, xAxisSelect.value, yAxisSelect.value));

          const rdiv = document.createElement('div');
          rdiv.style.textAlign = 'center';
          const cleanedData = data
            .filter(point =>
              point[0] !== undefined && point[1] !== undefined && !isNaN(point[0]) && !isNaN(point[1])
            ).map(point =>
              [Number(point[0]), Number(point[1])] // The values in data are not numbers for some reason.
            );
          let sxy = cleanedData.reduce((acc,e) => acc + e[0]*e[1], 0);
          let sx2 = cleanedData.reduce((acc,e) => acc + e[0]*e[0], 0);
          let sy2 = cleanedData.reduce((acc,e) => acc + e[1]*e[1], 0);
          let sx = cleanedData.reduce((acc,e) => acc + e[0], 0);
          let sy = cleanedData.reduce((acc,e) => acc + e[1], 0);
          let r = (cleanedData.length*sxy - sx*sy)/Math.sqrt((cleanedData.length * sx2 - Math.pow(sx, 2)) * (cleanedData.length * sy2 - Math.pow(sy, 2)));
          rdiv.textContent = "r = " + r.toFixed(4);
          document.getElementById('graphDiv').appendChild(rdiv);
        }
      }
      function getGrapherOption(text) {
        const option = document.createElement('option');
        option.textContent = renderKey(text, null, false);
        return option;
      }
      
      function handleLanguageChange(event) {
        fetchWords(LANGUAGE_TO_PATH_MAP[event.target.value]);
      }
      
      function fetchWords(path) {
        var oReq = new XMLHttpRequest();
        oReq.addEventListener("load", function() {
          // parse the words then escape
          const dataByNumWordsAndNumChars = myRecursiveEscape(JSON.parse(this.response));
          words = Object.create(null);
          for(const o1 of Object.values(dataByNumWordsAndNumChars)) {
            for(const o2 of Object.values(o1)) {
              for(const item of Object.values(o2)) {
                // I can't stand it being called "difficulty", so I rename it to "successRate"
                item.successRate = item.difficulty;
                delete item['difficulty'];

                words[item['word']] = item;
              }
            }
          }

          // attach success rate quantiles to words
          Object.keys(words)
            .filter(w => words[w].successRate != undefined)
            .sort((w1, w2) => words[w1].successRate - words[w2].successRate)
            .forEach((word, index, array) => {
              words[word].successRateQuantile = index / array.length
            });
            
          
          const xAxisSelect = document.getElementById('xAxisSelect');
          const yAxisSelect = document.getElementById('yAxisSelect');
          xAxisSelect.innerHTML = "<option>Select</option>";
          yAxisSelect.innerHTML = "<option id='numWordsWithXOption'>Number of words with the X value</option>";
          for(const attr in NAME_MAP) {
            xAxisSelect.appendChild(getGrapherOption(attr));
            yAxisSelect.appendChild(getGrapherOption(attr));
          }

          document.querySelector('#wordlist').innerHTML = getTableInnerHTML(
            words,
            sorts,
            [getFilterFromSkribblioHint(document.querySelector('#searchBox').value)]
          );

          showGraph();
        });
        
        oReq.open("GET", path);
        oReq.send();
      }

      function onLoad() {
        document.getElementById("languageSelect").addEventListener('change', handleLanguageChange);
        
        const ctx = document.getElementById('colorCanvas').getContext('2d');
        const OFFSET_X = 0;
        const OFFSET_Y = 20;
        const CANVAS_WIDTH = document.getElementById('colorCanvas').width;
        const CANVAS_HEIGHT = document.getElementById('colorCanvas').height;
        const NUM_STEPS = 500;
        for(let quantile = 0; quantile < 1; quantile += 1.0 / NUM_STEPS) {
          for(let whiteness = 0; whiteness < 1; whiteness += 1.0 / NUM_STEPS) {
            ctx.fillStyle = get_rgb_string(get_0_1_rgb_values(quantile, whiteness));
            ctx.fillRect(OFFSET_X + ((1 - quantile) * (CANVAS_WIDTH - OFFSET_X)), OFFSET_Y + (whiteness * (CANVAS_HEIGHT - OFFSET_Y)), 1, 1);
          }
        }
        ctx.fillStyle = 'black';
        ctx.font = '15px Arial';
        ctx.fillText('Easy', OFFSET_X, 15);
        ctx.fillText('Hard', CANVAS_WIDTH - 35, 15);
        
        if(!document.getElementById('colorCheckbox').checked) {
          document.getElementById('colorKey').style.display = "none";
        }
        if(!document.getElementById('showGrapherCheckbox').checked) {
          document.getElementById('grapher').style.display = "none";
        }
        
        fetchWords(LANGUAGE_TO_PATH_MAP[document.getElementById("languageSelect").value]);
      }
    </script>
  </head>
  <body onLoad="onLoad()">
    <div class='container'>
      <h2 style='text-align: center;'>skribbl.io default word list database</h2>
      <div>
        <p style='margin: 5px 10px;'>
          Below is a list of words that skribbl.io uses in public games.<br>
          Enter the hint provided by skribbl.io (e.g. <span style='letter-spacing: 2px;'>_oa__</span>) to search the list.
        </p>
        <form>
          <input type='checkbox' id='colorCheckbox' name='colorCheckbox' onClick='colorCheckboxOnClick.bind(this)()'>
          <label for='colorCheckbox'>Show difficulty of word using color</label>
          <br>
          <div id='colorKey'>
            <canvas id='colorCanvas' width='200' height='40'></canvas><br>
            <span style='font-size: 12px'>Colors closer to white indicate low confidence.  Perfect white indicates no data.</span>
            <br>
          </div>
          <input type='checkbox' id='showGrapherCheckbox' name='showGrapherCheckbox' onClick='showGrapherCheckboxOnClick.bind(this)()'>
          <label for='showGrapherCheckbox'>Show data grapher</label>
          <div style='float: right;'>
            Language: <select id="languageSelect">
              <option value="English">English</option>
              <option value="German">German</option>
              <option value="Spanish">Spanish</option>
            </select>
          </div>
          <br>
          <div id='grapher'>
            X Axis
            <select id='xAxisSelect' onchange='showGraph()'>
              <!-- options are added by JavaScript code -->
            </select>
            <br>
            Y Axis
            <select id='yAxisSelect' onchange='showGraph()'>
              <!-- options are added by JavaScript code -->
            </select>
            <div id='graphDiv'></div>
            <div id='rDiv'></div>
          </div>
        </form>
      </div>
      <form>
        <input type='text' id='searchBox' oninput='searchBoxOnInput.bind(this)()' placeholder='Search by blanks, for example _____b____' style="width: 100%; letter-spacing: 2px; margin: 3px;">
      </form>
      <div id='wordlist' style="margin: 3px;">
         Retrieving word list.  This may take up to 30 seconds.
      </div>
    </div>
  </body>
</html>
